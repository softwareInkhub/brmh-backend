# Caching Implementation Documentation

## Overview
The caching system in the BRMH service is implemented to optimize performance and reduce the load on DynamoDB by storing frequently accessed data in memory. This document outlines the caching mechanism, its configuration, and usage.

## Cache Configuration

### Cache Storage
```javascript
const scanCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes in milliseconds
```

- **Storage Type**: In-memory Map
- **TTL (Time To Live)**: 5 minutes
- **Scope**: Application-level (cleared on server restart)

### Cache Key Generation
```javascript
function generateCacheKey(tableName, params) {
  return `${tableName}:${JSON.stringify(params)}`;
}
```

The cache key is generated by combining:
- Table name
- Query parameters (stringified)
- This ensures unique keys for different query combinations

## Cache Implementation Details

### 1. Cache Structure
- Uses JavaScript's native `Map` data structure
- Key: Generated cache key string
- Value: Object containing:
  - `data`: The cached response
  - `timestamp`: When the cache entry was created

### 2. Cache Operations

#### Reading from Cache
```javascript
const cacheKey = generateCacheKey(tableName, params);
const cachedData = scanCache.get(cacheKey);

if (cachedData && (Date.now() - cachedData.timestamp) < CACHE_TTL) {
  return cachedData.data;
}
```

#### Writing to Cache
```javascript
scanCache.set(cacheKey, {
  data: response,
  timestamp: Date.now()
});
```

### 3. Cache Invalidation
- Automatic: Entries expire after TTL (5 minutes)
- Manual: Cache is cleared when:
  - New items are created
  - Items are updated
  - Items are deleted

## Usage Guidelines

### When to Use Cache
1. **Read-Heavy Operations**: Ideal for frequently accessed, rarely changed data
2. **Expensive Queries**: Complex scans or queries that are resource-intensive
3. **Consistent Data**: Data that doesn't change frequently

### When Not to Use Cache
1. **Write-Heavy Operations**: Data that changes frequently
2. **Real-time Data**: When data freshness is critical
3. **Sensitive Data**: When data security is paramount

## Performance Considerations

### Memory Usage
- Cache size is limited by available system memory
- Each cached item includes:
  - Response data
  - Timestamp
  - Metadata

### Cache Hit Ratio
- Monitor cache hit ratio to optimize TTL
- Adjust TTL based on data update frequency
- Consider implementing cache size limits

## Best Practices

1. **Cache Key Design**
   - Keep keys concise but unique
   - Include all relevant query parameters
   - Avoid storing sensitive data in keys

2. **TTL Management**
   - Set TTL based on data update frequency
   - Consider implementing variable TTLs
   - Monitor cache effectiveness

3. **Error Handling**
   - Implement fallback mechanisms
   - Handle cache misses gracefully
   - Log cache-related errors

4. **Monitoring**
   - Track cache hit/miss rates
   - Monitor memory usage
   - Log cache operations

## Example Usage

```javascript
// Reading with cache
async function getCachedItems(tableName, params) {
  const cacheKey = generateCacheKey(tableName, params);
  const cachedData = scanCache.get(cacheKey);

  if (cachedData && (Date.now() - cachedData.timestamp) < CACHE_TTL) {
    return cachedData.data;
  }

  // If not in cache or expired, fetch from DynamoDB
  const response = await fetchFromDynamoDB(tableName, params);
  
  // Update cache
  scanCache.set(cacheKey, {
    data: response,
    timestamp: Date.now()
  });

  return response;
}
```

## Limitations

1. **Memory Constraints**
   - Cache size limited by available memory
   - No persistent storage
   - Cleared on server restart

2. **Scalability**
   - Single-server cache
   - No distributed caching
   - No cache synchronization

3. **Data Consistency**
   - Potential for stale data
   - TTL-based invalidation only
   - No real-time updates

## Future Improvements

1. **Distributed Caching**
   - Implement Redis or similar
   - Enable multi-server caching
   - Improve scalability

2. **Advanced Features**
   - Cache size limits
   - LRU eviction
   - Cache warming
   - Cache statistics

3. **Monitoring**
   - Cache hit/miss metrics
   - Memory usage tracking
   - Performance analytics 